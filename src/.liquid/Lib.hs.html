<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>src/Lib.hs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
<pre><span class=hs-linenum> 1: </span><a class=annot href="#"><span class=annottext>GHC.Types.Module</span><span class='hs-keyword'>module</span></a> <span class='hs-conid'>Lib</span>
<span class=hs-linenum> 2: </span>    <span class='hs-layout'>(</span> <span class='hs-varid'>genARandomPreFactoredNumberLEn</span>
<span class=hs-linenum> 3: </span>     <span class='hs-layout'>,</span><span class='hs-varid'>firstPrimeLE</span>
<span class=hs-linenum> 4: </span>     <span class='hs-layout'>,</span><span class='hs-varid'>createSeq</span>
<span class=hs-linenum> 5: </span>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 6: </span>
<span class=hs-linenum> 7: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Numbers.Primes</span> <span class='hs-layout'>(</span><span class='hs-varid'>isPrime</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 8: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>System.Random.Stateful</span> <span class='hs-layout'>(</span><span class='hs-varid'>uniformRM</span><span class='hs-layout'>,</span> <span class='hs-varid'>globalStdGen</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 9: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>RefinementHelper</span> 
<span class=hs-linenum>10: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>ShortCircuit</span> <span class='hs-layout'>(</span><span class='hs-varid'>if'</span><span class='hs-layout'>)</span>
<span class=hs-linenum>11: </span>
<span class=hs-linenum>12: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lazy</span> <span class='hs-varid'>genARandomPreFactoredNumberLEn</span> <span class='hs-keyword'>@-}</span> <span class='hs-comment'>-- disabling termination checking</span>
<span class=hs-linenum>13: </span><span class='hs-definition'>genARandomPreFactoredNumberLEn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-conid'>String</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>14: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; (GHC.Types.IO (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])))</span><span class='hs-definition'>genARandomPreFactoredNumberLEn</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])) -&gt; (GHC.Types.IO (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])))</span><span class='hs-varid'>pure</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])) | isLeft v}</span><span class='hs-conid'>Left</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Invalid"</span></a>
<span class=hs-linenum>15: </span><span class='hs-definition'>genARandomPreFactoredNumberLEn</span> <span class='hs-num'>1</span>           <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])) -&gt; (GHC.Types.IO (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])))</span><span class='hs-varid'>pure</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])) | not (isLeft v)}</span><span class='hs-conid'>Right</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.Int, [GHC.Types.Int])</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Int]</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class=hs-linenum>16: </span><span class='hs-definition'>genARandomPreFactoredNumberLEn</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>2</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> 
<span class=hs-linenum>17: </span>                                                <a class=annot href="#"><span class=annottext>(Data.Either.Either [GHC.Types.Char] {v : GHC.Types.Int | v /= 0
                                                          &amp;&amp; v &gt; 0
                                                          &amp;&amp; v &gt;= 0
                                                          &amp;&amp; 0 &lt; v
                                                          &amp;&amp; 2 &lt;= v})</span><span class='hs-varid'>rndM</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (Data.Either.Either [GHC.Types.Char] {v : GHC.Types.Int | v /= 0
                                                                        &amp;&amp; v &gt; 0
                                                                        &amp;&amp; v &gt;= 0
                                                                        &amp;&amp; 0 &lt; v
                                                                        &amp;&amp; 2 &lt;= v}))</span><span class='hs-varid'>fmap</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; (Data.Either.Either [GHC.Types.Char] {v : GHC.Types.Int | 2 &lt;= v})</span><span class='hs-varid'>filterInvalid</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.IO GHC.Types.Int)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>getRndMInt</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Types.Int, GHC.Types.Int) | snd v == x
                                      &amp;&amp; x_Tuple22 v == x}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>2</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>n</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> 
<span class=hs-linenum>18: </span>                                                <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{v : (Data.Either.Either [GHC.Types.Char] {v : GHC.Types.Int | v /= 0
                                                               &amp;&amp; v &gt; 0
                                                               &amp;&amp; v &gt;= 0
                                                               &amp;&amp; 0 &lt; v
                                                               &amp;&amp; 2 &lt;= v}) | v == rndM}</span><span class='hs-varid'>rndM</span></a> <span class='hs-keyword'>of</span> 
<span class=hs-linenum>19: </span>                                                    <span class='hs-conid'>Left</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])) -&gt; (GHC.Types.IO (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])))</span><span class='hs-varid'>pure</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])) | isLeft v}</span><span class='hs-conid'>Left</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Invalid"</span></a>
<span class=hs-linenum>20: </span>                                                    <span class='hs-conid'>Right</span> <span class='hs-varid'>upper</span>  <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : (ShortCircuit.Shortcircuit GHC.Types.Bool) | v == $fShortcircuitBool}</span><span class='hs-varid'>if'</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v &lt;=&gt; ps &lt;= x}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == ps}</span><span class='hs-varid'>ps</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>n</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])))</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>(Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])) -&gt; (GHC.Types.IO (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])))</span><span class='hs-varid'>pure</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])) | not (isLeft v)}</span><span class='hs-conid'>Right</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Types.Int, [GHC.Types.Int]) | v == rsp}</span><span class='hs-varid'>rsp</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])))</span><span class='hs-layout'>(</span></a><span class='hs-varid'>genARandomPreFactoredNumberLEn</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>n</span></a><span class='hs-layout'>)</span> <span class='hs-comment'>--if' from shortcircuit, used here for convenience not lazy evaluation</span>
<span class=hs-linenum>21: </span>                                                                        <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>(GHC.Types.Int, [GHC.Types.Int])</span><span class='hs-varid'>rsp</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>ps</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : [GHC.Types.Int] | false}</span><span class='hs-varid'>sq</span></a><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>({v : GHC.Types.Int | false}, {v : [GHC.Types.Int] | false})&lt;\_ VV -&gt; {v : [GHC.Types.Int] | false}&gt;</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>product</span></a> <a class=annot href="#"><span class=annottext>{VV : [GHC.Types.Int] | false}</span><span class='hs-varid'>sq</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : [{v : GHC.Types.Int | v &gt;= 0
                           &amp;&amp; 0 &lt; v}] | 1 &lt;= len v}</span><span class='hs-varid'>createSeq</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == upper
                     &amp;&amp; v /= 0
                     &amp;&amp; v &gt; 0
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v
                     &amp;&amp; 2 &lt;= v}</span><span class='hs-varid'>upper</span></a><span class='hs-layout'>)</span> <span class='hs-comment'>-- Haskell as-pattern @</span>
<span class=hs-linenum>22: </span><span class='hs-definition'>genARandomPreFactoredNumberLEn</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])) -&gt; (GHC.Types.IO (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])))</span><span class='hs-varid'>pure</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : (Data.Either.Either [GHC.Types.Char] (GHC.Types.Int, [GHC.Types.Int])) | isLeft v}</span><span class='hs-conid'>Left</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Invalid"</span></a>
<span class=hs-linenum>23: </span>
<span class=hs-linenum>24: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lazy</span> <span class='hs-varid'>createSeq</span> <span class='hs-keyword'>@-}</span> <span class='hs-comment'>-- disabling termination checking</span>
<span class=hs-linenum>25: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>createSeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Pos</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PrimeFactors</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>26: </span><span class='hs-definition'>createSeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>27: </span><a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | VV &gt;= 0
                      &amp;&amp; 0 &lt; VV} -&gt; {VV : [{VV : GHC.Types.Int | VV &gt;= 0
                                                                 &amp;&amp; 0 &lt; VV}] | 1 &lt;= len VV}</span><span class='hs-definition'>createSeq</span></a> <span class='hs-num'>1</span>                  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | len v == 0}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-keyglyph'>]</span>      
<span class=hs-linenum>28: </span><span class='hs-definition'>createSeq</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>2</span></a>         <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>(Data.Either.Either [GHC.Types.Char] {v : GHC.Types.Int | v &gt;= 0
                                                          &amp;&amp; 0 &lt; v})</span><span class='hs-varid'>filterInvalidNonPos</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>n</span></a> <span class='hs-keyword'>of</span> 
<span class=hs-linenum>29: </span>                                <span class='hs-conid'>Left</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | VV &gt;= 0
                      &amp;&amp; 0 &lt; VV} -&gt; {VV : [{VV : GHC.Types.Int | VV &gt;= 0
                                                                 &amp;&amp; 0 &lt; VV}] | 1 &lt;= len VV}</span><span class='hs-varid'>createSeq</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a>
<span class=hs-linenum>30: </span>                                <span class='hs-comment'>-- Right nGte1  -&gt; if' fVal (si : createSeq rght) (createSeq 1 )</span>
<span class=hs-linenum>31: </span>                                <span class='hs-comment'>--                     where (si, fVal, rght) = (firstPrimeLE nGte1, filterInvalidNonPos (si-1), fromRight fVal)</span>
<span class=hs-linenum>32: </span>                                <span class='hs-conid'>Right</span> <span class='hs-varid'>nGte1</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> 
<span class=hs-linenum>33: </span>                                                    <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>(Data.Either.Either [GHC.Types.Char] {v : GHC.Types.Int | v &gt;= 0
                                                          &amp;&amp; 0 &lt; v})</span><span class='hs-varid'>filterInvalidNonPos</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == si
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>si</span></a><span class='hs-comment'>-</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<span class=hs-linenum>34: </span>                                                        <span class='hs-conid'>Left</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | VV &gt;= 0
                      &amp;&amp; 0 &lt; VV} -&gt; {VV : [{VV : GHC.Types.Int | VV &gt;= 0
                                                                 &amp;&amp; 0 &lt; VV}] | 1 &lt;= len VV}</span><span class='hs-varid'>createSeq</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a> 
<span class=hs-linenum>35: </span>                                                        <span class='hs-conid'>Right</span> <span class='hs-varid'>okN</span>    <span class='hs-keyglyph'>-&gt;</span>  <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == si
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>si</span></a> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{v : [{v : GHC.Types.Int | v &gt;= 0
                           &amp;&amp; 0 &lt; v}] | 1 &lt;= len v}</span><span class='hs-varid'>createSeq</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == okN
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>okN</span></a>
<span class=hs-linenum>36: </span>                                                <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>si</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>firstPrimeLE</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == nGte1
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>nGte1</span></a>
<span class=hs-linenum>37: </span><span class='hs-definition'>createSeq</span> <span class='hs-keyword'>_</span>                  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a . {v : [GHC.Types.Char] | false} -&gt; a | VV == die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"impossible"</span></a>
<span class=hs-linenum>38: </span>
<span class=hs-linenum>39: </span>
<span class=hs-linenum>40: </span><span class='hs-comment'>--{-@ lazy firstPrimeLE @-} -- disabling termination checking</span>
<span class=hs-linenum>41: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>firstPrimeLE</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Pos</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Pos</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>42: </span><span class='hs-definition'>firstPrimeLE</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>43: </span><a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | VV &gt;= 0
                      &amp;&amp; 0 &lt; VV} -&gt; {VV : GHC.Types.Int | VV &gt;= 0
                                                          &amp;&amp; 0 &lt; VV}</span><span class='hs-definition'>firstPrimeLE</span></a> <span class='hs-num'>1</span>             <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == 1}</span><span class='hs-num'>1</span></a>
<span class=hs-linenum>44: </span><span class='hs-definition'>firstPrimeLE</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>isPrime</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>n</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>n</span></a>
<span class=hs-linenum>45: </span><span class='hs-definition'>firstPrimeLE</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | VV &gt;= 0
                      &amp;&amp; 0 &lt; VV} -&gt; {VV : GHC.Types.Int | VV &gt;= 0
                                                          &amp;&amp; 0 &lt; VV}</span><span class='hs-varid'>firstPrimeLE</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; 0 &lt; v}</span><span class='hs-varid'>n</span></a><span class='hs-comment'>-</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>46: </span><span class='hs-definition'>firstPrimeLE</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a . {v : [GHC.Types.Char] | false} -&gt; a | VV == die}</span><span class='hs-varid'>die</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"impossible"</span></a>
<span class=hs-linenum>47: </span>
<span class=hs-linenum>48: </span>
<span class=hs-linenum>49: </span><span class='hs-comment'>-- helper functions</span>
<span class=hs-linenum>50: </span><span class='hs-comment'>-- get a random integer given a lower and upper bound</span>
<span class=hs-linenum>51: </span><span class='hs-definition'>getRndMInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>52: </span><a class=annot href="#"><span class=annottext>({VV : GHC.Types.Int | VV /= 0
                       &amp;&amp; VV &gt; 0
                       &amp;&amp; VV &gt;= 0
                       &amp;&amp; 0 &lt; VV
                       &amp;&amp; 2 &lt;= VV}, {VV : GHC.Types.Int | VV /= 0
                                                          &amp;&amp; VV &gt; 0
                                                          &amp;&amp; VV &gt;= 0
                                                          &amp;&amp; 0 &lt; VV
                                                          &amp;&amp; 2 &lt;= VV})&lt;\x1 VV -&gt; {VV : GHC.Types.Int | VV /= 0
                                                                                                       &amp;&amp; VV &gt; 0
                                                                                                       &amp;&amp; VV &gt;= 0
                                                                                                       &amp;&amp; VV &gt;= x1
                                                                                                       &amp;&amp; 0 &lt; VV
                                                                                                       &amp;&amp; 2 &lt;= VV}&gt; -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-definition'>getRndMInt</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>l</span><span class='hs-layout'>,</span><span class='hs-varid'>u</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (System.Random.Internal.StatefulGen (System.Random.Stateful.AtomicGenM System.Random.Internal.StdGen) GHC.Types.IO) | v == $dStatefulGen_a86t}</span><span class='hs-varid'>uniformRM</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Types.Int, GHC.Types.Int) | fst v == l
                                      &amp;&amp; snd v == u
                                      &amp;&amp; x_Tuple21 v == l
                                      &amp;&amp; x_Tuple22 v == u}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l
                     &amp;&amp; v /= 0
                     &amp;&amp; v &gt; 0
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; 0 &lt; v
                     &amp;&amp; 2 &lt;= v}</span><span class='hs-varid'>l</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == u
                     &amp;&amp; v /= 0
                     &amp;&amp; v &gt; 0
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; v &gt;= l
                     &amp;&amp; 0 &lt; v
                     &amp;&amp; 2 &lt;= v}</span><span class='hs-varid'>u</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (System.Random.Stateful.AtomicGenM System.Random.Internal.StdGen) | v == globalStdGen}</span><span class='hs-varid'>globalStdGen</span></a> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>53: </span>
<span class=hs-linenum>54: </span>
<span class=hs-linenum>55: </span><span class='hs-comment'>-- kind of dicey 'unsafe function' I assume that the value will always be Right something</span>
<span class=hs-linenum>56: </span><span class='hs-definition'>fromRight</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Either</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span>
<span class=hs-linenum>57: </span><a class=annot href="#"><span class=annottext>forall a b .
{VV : (Data.Either.Either {VV : a | false} b) | false} -&gt; b</span><span class='hs-definition'>fromRight</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == v}</span><span class='hs-varid'>v</span></a>
<span class=hs-linenum>58: </span><span class='hs-definition'>fromRight</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Classes.IP [GHC.Types.Char] GHC.Stack.Types.CallStack) | v == $dIP_a86g}</span><span class='hs-varid'>error</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"ouch"</span></a>
<span class=hs-linenum>59: </span>
</pre>
</body>
</html>